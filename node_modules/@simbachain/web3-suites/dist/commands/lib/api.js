"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.primaryConstructorRequiresArgs = exports.primaryConstructorInputs = exports.primaryContractConstructor = exports.getFieldFromPrimaryContractABI = exports.getStorages = exports.getBlockchains = exports.chooseApplicationFromList = exports.selectNewApplicationName = exports.chooseApplicationFromName = exports.getABIForPrimaryContract = exports.writeAndReturnASTAndOtherInfo = exports.getASTAndOtherInfo = exports.astAndOtherInfo = exports.isLibrary = exports.getContractKind = exports.getASTNodes = exports.buildInfoJsonName = exports.parseBuildInfoJsonName = exports.chooseOrganisationFromName = exports.chooseOrganisationFromList = exports.getList = exports.WindowsOrMacFileName = void 0;
const prompts_1 = __importDefault(require("prompts"));
const lib_1 = require("../lib");
const _1 = require("./");
const fs = __importStar(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const axios_1 = __importDefault(require("axios"));
const authentication_1 = require("./authentication");
/**
 * determines filename, whether on mac or windows machine
 * @param filePath
 * @returns
 */
function WindowsOrMacFileName(filePath) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${filePath}`);
    const fileName = filePath.split('\\').pop().split('/').pop();
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${fileName}`);
    return fileName;
}
exports.WindowsOrMacFileName = WindowsOrMacFileName;
/**
 * used to retrieve lists of applications and organisations, mainly
 * @param config
 * @param url
 * @returns
 */
exports.getList = async (config, url) => {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    if (!url) {
        url = 'v2/organisations/';
    }
    const authStore = await config.authStore();
    if (authStore) {
        try {
            const res = await authStore.doGetRequest(url);
            lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(res)}`);
            return res;
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error.response.data)}`)}`);
            }
            else {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error)}`)}`);
            }
            if (axios_1.default.isAxiosError(error) && error.message === "Request failed with status code 500") {
                lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright('\nsimba: Auth token expired, please log in again')}`);
                authStore.logout();
                await authStore.loginAndGetAuthToken();
            }
        }
    }
    else {
        lib_1.SimbaConfig.log.error(authentication_1.authErrors.badAuthProviderInfo);
    }
};
/**
 * choose SIMBA org from list
 * @param config
 * @param url
 * @returns
 */
exports.chooseOrganisationFromList = async (config, url) => {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(config)}`);
    if (!url) {
        url = 'v2/organisations/';
    }
    const orgResponse = await exports.getList(config, url);
    if (!orgResponse) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : no organizations returned. You probably need to log in again')}`);
        return;
    }
    if (orgResponse.results) {
        lib_1.SimbaConfig.log.debug(`orgResponse.results: ${JSON.stringify(orgResponse.results)}`);
    }
    if (!orgResponse.results || !orgResponse.results.length) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: There are no organisations present. You must create an organisation to use the plugin.`)}`);
    }
    lib_1.SimbaConfig.log.debug(`orgResponse.results: ${JSON.stringify(orgResponse.results)}`);
    if (!orgResponse.results || !orgResponse.results.length) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: No organisations present`)}`);
        return;
    }
    const orgs = {
        next: orgResponse.next,
        prev: orgResponse.prev,
        data: orgResponse.results.reduce((map, obj) => {
            const data = Object.assign(Object.assign({}, obj), { id: obj.id });
            map[data.name] = data;
            return map;
        }, {}),
    };
    const choices = [];
    if (orgs.prev) {
        choices.push({
            title: '<-',
            description: 'Previous choices',
            value: 'prev'
        });
    }
    if (orgs.next) {
        choices.push({ title: '-> Next Page', description: 'Next choices', value: 'next' });
    }
    for (const [key, val] of Object.entries(orgs.data)) {
        choices.push({ title: key, value: val });
    }
    if (orgs.next) {
        choices.push({ title: '-> Next Page', description: 'Next choices', value: 'next' });
    }
    const response = await prompts_1.default({
        type: 'select',
        name: 'organisation',
        message: 'Please pick an organisation',
        choices,
    });
    lib_1.SimbaConfig.log.debug(`selected organisation: ${JSON.stringify(response.organisation)}`);
    if (response.organisation === 'prev') {
        return exports.chooseOrganisationFromList(config, orgs.prev);
    }
    else if (response.organisation === 'next') {
        return exports.chooseOrganisationFromList(config, orgs.next);
    }
    if (!response.organisation) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : No Organisation Selected!')}`);
        throw new Error('No Organisation Selected!');
    }
    config.organisation = response.organisation;
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(response.organisation)}`);
    return response.organisation;
};
/**
 * select SIMBA organisation from name
 * @param config
 * @param orgName
 * @returns
 */
async function chooseOrganisationFromName(config, orgName) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${orgName}`);
    const url = `v2/organisations/${orgName}/`;
    const authStore = await config.authStore();
    if (authStore) {
        try {
            const res = await authStore.doGetRequest(url);
            lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`simba: logging in using organisation ${res.name}`)}`);
            lib_1.SimbaConfig.log.debug(`:: EXIT : res : ${JSON.stringify(res)}`);
            lib_1.SimbaConfig.organisation = res;
            return res;
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error.response.data)}`)}`);
            }
            else {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error)}`)}`);
            }
            if (axios_1.default.isAxiosError(error) && error.message === "Request failed with status code 500") {
                lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright('\nsimba: Auth token expired, please log in again')}`);
                authStore.logout();
                await authStore.loginAndGetAuthToken();
            }
        }
    }
    else {
        lib_1.SimbaConfig.log.error(authentication_1.authErrors.badAuthProviderInfo);
    }
}
exports.chooseOrganisationFromName = chooseOrganisationFromName;
/**
 * Used for Hardhat, which stores AST separately from ABI
 * @param location
 * @returns
 */
function parseBuildInfoJsonName(location) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${location}`);
    const fileName = WindowsOrMacFileName(location);
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${fileName}`);
    return fileName || location;
}
exports.parseBuildInfoJsonName = parseBuildInfoJsonName;
/**
 * Used for Hardhat, which stores AST separately from ABI
 * @param contractName
 * @param contractSourceName
 * @returns
 */
async function buildInfoJsonName(contractName, contractSourceName) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${contractName}`);
    const buildDir = lib_1.SimbaConfig.buildDirectory;
    let files = [];
    try {
        files = await _1.walkDirForContracts(buildDir, ".json");
    }
    catch (e) {
        const err = e;
        if (err.code === 'ENOENT') {
            lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : Simba was not able to find any build info artifacts.\nDid you forget to compile?\n')}`);
            return "";
        }
        lib_1.SimbaConfig.log.error(`:: EXIT : ERROR : ${JSON.stringify(err)}`);
        return "";
    }
    for (const file of files) {
        if (!(file.endsWith(`${contractSourceName}/${contractName}.dbg.json`))
            && !(file.endsWith(`${contractSourceName}\\${contractName}.dbg.json`))) {
            continue;
        }
        else {
            const buf = await _1.promisifiedReadFile(file, { flag: 'r' });
            const parsed = JSON.parse(buf.toString());
            const location = parsed.buildInfo;
            const jsonName = parseBuildInfoJsonName(location);
            lib_1.SimbaConfig.log.debug(`:: EXIT : ${jsonName}`);
            return jsonName;
        }
    }
    lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : no info found for contract')}`);
    return "";
}
exports.buildInfoJsonName = buildInfoJsonName;
/**
 * Mainly used to determine if a contract is a library, contract, interface, etc.
 * @param ast
 * @returns
 */
function getASTNodes(ast) {
    const astNodes = ast.nodes ? ast.nodes : [];
    return astNodes;
}
exports.getASTNodes = getASTNodes;
/**
 * returns type of contract (library, contract, interface)
 * @param ast
 * @returns
 */
function getContractKind(contractName, ast) {
    const astNodes = getASTNodes(ast);
    for (let i = 0; i < astNodes.length; i++) {
        const node = astNodes[i];
        if (node.contractKind && (node.name === contractName)) {
            const contractKind = node.contractKind;
            lib_1.SimbaConfig.log.debug(`contractKind: ${contractKind}`);
            return contractKind;
        }
    }
    return "";
}
exports.getContractKind = getContractKind;
/**
 * determines if a contract is a library
 * @param ast
 * @returns
 */
function isLibrary(contractName, ast) {
    const contractKind = getContractKind(contractName, ast);
    const _isLibrary = (contractKind === "library");
    lib_1.SimbaConfig.log.debug(`isLibrary: ${_isLibrary}`);
    return _isLibrary;
}
exports.isLibrary = isLibrary;
/**
 * Used for Hardhat, which stores AST separately from ABI
 * @param contractName
 * @param contractSourceName
 * @param _buildInfoJsonName
 * @returns
 */
async function astAndOtherInfo(contractName, contractSourceName, _buildInfoJsonName) {
    const params = {
        contractName,
        contractSourceName,
        _buildInfoJsonName,
    };
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(params)}`);
    const buildInfoDir = lib_1.SimbaConfig.buildInfoDirectory;
    const buildDir = lib_1.SimbaConfig.buildDirectory;
    let files = [];
    let _astAndOtherInfo = {
        ast: {},
        source: {},
        compiler: "",
        language: "",
        isLib: false,
        contractName,
        contractSourceName,
    };
    const web3Suite = lib_1.discoverAndSetWeb3Suite();
    if (!web3Suite) {
        throw new Error(lib_1.web3SuiteErrorMessage);
    }
    if (web3Suite === "hardhat") {
        try {
            files = await _1.walkDirForContracts(buildInfoDir, ".json");
            lib_1.SimbaConfig.log.debug(`:: files : ${JSON.stringify(files)}`);
        }
        catch (e) {
            const err = e;
            if (err.code === 'ENOENT') {
                lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : Simba was not able to find any build info artifacts.\nDid you forget to compile?\n')}`);
                return _astAndOtherInfo;
            }
            lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(err)}`)}`);
            return _astAndOtherInfo;
        }
    }
    if (web3Suite === "truffle") {
        try {
            files = await _1.walkDirForContracts(buildDir, ".json");
            lib_1.SimbaConfig.log.debug(`:: files : ${JSON.stringify(files)}`);
        }
        catch (e) {
            const err = e;
            if (err.code === 'ENOENT') {
                lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : Simba was not able to find any build info artifacts.\nDid you forget to compile?\n')}`);
                return _astAndOtherInfo;
            }
            lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(err)}`)}`);
            return _astAndOtherInfo;
        }
    }
    if (web3Suite === "hardhat") {
        for (const file of files) {
            if (!(file.endsWith(_buildInfoJsonName))) {
                continue;
            }
            else {
                const buf = await _1.promisifiedReadFile(file, { flag: 'r' });
                const parsed = JSON.parse(buf.toString());
                const output = parsed.output;
                const outputSources = output.sources;
                const outputContractSource = outputSources[contractSourceName];
                const ast = outputContractSource.ast;
                _astAndOtherInfo.ast = ast;
                _astAndOtherInfo.isLib = isLibrary(contractName, ast);
                const solcVersion = parsed.solcVersion;
                _astAndOtherInfo.compiler = solcVersion;
                const input = parsed.input;
                const language = parsed.language;
                const inputSources = input.sources;
                const inputContractSource = inputSources[contractSourceName];
                const contractSourceCode = inputContractSource.content;
                _astAndOtherInfo.source = contractSourceCode;
                _astAndOtherInfo.language = language;
                lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(_astAndOtherInfo)}`);
                return _astAndOtherInfo;
            }
        }
        lib_1.SimbaConfig.log.error(`:: EXIT : ERROR : no contract info found for ${contractName}. please clean your build files by running 'npx hardhat clean' and then compile again with 'npx hardhat compile'`);
        return _astAndOtherInfo;
    }
    if (web3Suite === "truffle") {
        for (const file of files) {
            if (!(file.endsWith(`${contractName}.json`))) {
                continue;
            }
            else {
                const buf = await _1.promisifiedReadFile(file, { flag: 'r' });
                const parsed = JSON.parse(buf.toString());
                const ast = parsed.ast;
                _astAndOtherInfo.ast = ast;
                lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(_astAndOtherInfo)}`);
                return _astAndOtherInfo;
            }
        }
        lib_1.SimbaConfig.log.error(`:: EXIT : ERROR : no contract info found for ${contractName}`);
        return _astAndOtherInfo;
    }
    lib_1.SimbaConfig.log.error(`:: EXIT : ERROR : no contract info found for ${contractName}`);
    return _astAndOtherInfo;
}
exports.astAndOtherInfo = astAndOtherInfo;
/**
 * Used for Hardhat, which stores AST separately from ABI
 * @param contractName
 * @param contractSourceName
 * @returns
 */
async function getASTAndOtherInfo(contractName, contractSourceName) {
    const entryParams = {
        contractName,
        contractSourceName,
    };
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(entryParams)}`);
    let _buildInfoJsonName;
    const web3Suite = lib_1.discoverAndSetWeb3Suite();
    if (!web3Suite) {
        throw new Error(lib_1.web3SuiteErrorMessage);
    }
    if (web3Suite === "hardhat") {
        _buildInfoJsonName = await buildInfoJsonName(contractName, contractSourceName);
    }
    const _astAndOtherInfo = await astAndOtherInfo(contractName, contractSourceName, _buildInfoJsonName);
    if (Object.keys(_astAndOtherInfo.ast).length === 0) {
        const message = `no ast found for ${contractName}`;
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: EXIT : ${message}`)}`);
        throw new Error(`${message}`);
    }
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(_astAndOtherInfo)}`);
    return _astAndOtherInfo;
}
exports.getASTAndOtherInfo = getASTAndOtherInfo;
/**
 * Used for Hardhat, which stores AST separately from ABI
 * This actually writes the AST to the build file containing the ABI
 * @param contractName
 * @param contractSourceName
 * @returns
 */
async function writeAndReturnASTAndOtherInfo(contractName, contractSourceName) {
    const entryParams = {
        contractName,
        contractSourceName,
    };
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(entryParams)}`);
    const _astAndOtherInfo = await getASTAndOtherInfo(contractName, contractSourceName);
    const buildDir = lib_1.SimbaConfig.buildDirectory;
    const files = await _1.walkDirForContracts(buildDir, ".json");
    for (const file of files) {
        if (!(file.endsWith(`/${contractName}.json`))) {
            continue;
        }
        const buf = await _1.promisifiedReadFile(file, { flag: 'r' });
        const parsed = JSON.parse(buf.toString());
        parsed.ast = _astAndOtherInfo.ast;
        parsed.source = _astAndOtherInfo.source;
        const data = JSON.stringify(parsed);
        lib_1.SimbaConfig.log.debug(`:: writing to ${file}`);
        fs.writeFileSync(file, data);
        lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(_astAndOtherInfo)}`);
        return _astAndOtherInfo;
    }
    return _astAndOtherInfo;
}
exports.writeAndReturnASTAndOtherInfo = writeAndReturnASTAndOtherInfo;
/**
 * Used for Hardhat, which stores AST separately from ABI
 * @returns
 */
async function getABIForPrimaryContract() {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const contractName = lib_1.SimbaConfig.ProjectConfigStore.get("primary");
    if (!contractName) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : no primary contract in simba.json')}`);
        return "";
    }
    const buildDir = lib_1.SimbaConfig.buildDirectory;
    lib_1.SimbaConfig.log.debug(`buildDir: ${buildDir}`);
    const files = await _1.walkDirForContracts(buildDir, ".json");
    for (const file of files) {
        lib_1.SimbaConfig.log.debug(`:: file : ${JSON.stringify(file)}`);
        const fileName = WindowsOrMacFileName(file);
        if (fileName !== `${contractName}.json`) {
            continue;
        }
        const buf = await _1.promisifiedReadFile(file, { flag: 'r' });
        const parsed = JSON.parse(buf.toString());
        const abi = parsed.abi;
        lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(abi)}`);
        return abi;
    }
    lib_1.SimbaConfig.log.debug(`:: no abi found for contract ${contractName}`);
    lib_1.SimbaConfig.log.debug(`:: EXIT :`);
    return;
}
exports.getABIForPrimaryContract = getABIForPrimaryContract;
/**
 * choose SIMBA application from application name
 * @param config
 * @param id
 * @returns
 */
async function chooseApplicationFromName(config, appName) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${appName}`);
    const url = `v2/organisations/${config.organisation.id}/applications/${appName}/`;
    const authStore = await config.authStore();
    if (authStore) {
        try {
            const res = await authStore.doGetRequest(url, 'application/json');
            lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(res)}`);
            lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`simba: logging in using app ${res.name}`)}`);
            lib_1.SimbaConfig.application = res;
            return res;
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error.response.data)}`)}`);
            }
            else {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error)}`)}`);
            }
            if (axios_1.default.isAxiosError(error) && error.message === "Request failed with status code 500") {
                lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright('\nsimba: Auth token expired, please log in again')}`);
                authStore.logout();
                await authStore.loginAndGetAuthToken();
            }
        }
    }
    else {
        lib_1.SimbaConfig.log.error(authentication_1.authErrors.badAuthProviderInfo);
    }
}
exports.chooseApplicationFromName = chooseApplicationFromName;
;
/**
 * select a name for a new SIMBA app
 * @param config
 * @returns
**/
async function selectNewApplicationName(config) {
    const appName = await prompts_1.default({
        type: 'text',
        name: 'app_name',
        message: 'Please enter the name of your app',
    });
    if (!appName.app_name) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : no application name specified!')}`);
        return;
    }
    const authStore = await config.authStore();
    const url = `v2/organisations/${config.organisation.id}/applications/validate/${appName.app_name}/`;
    if (authStore) {
        try {
            const appNameResponse = await authStore.doGetRequest(url, 'application/json');
            return appName.app_name;
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                if (error.response.data.errors[0].code == 1400) {
                    lib_1.SimbaConfig.log.error(`\nsimba: Invalid app name: ${error.response.data.errors[0].detail}`);
                    return await selectNewApplicationName(config);
                }
                else {
                    lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error.response.data)}`)}`);
                }
            }
            else {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error)}`)}`);
            }
            if (axios_1.default.isAxiosError(error) && error.message === "Request failed with status code 500") {
                lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright('\nsimba: Auth token expired, please log in again')}`);
                authStore.logout();
                await authStore.loginAndGetAuthToken();
                return await selectNewApplicationName(config);
            }
        }
    }
    else {
        lib_1.SimbaConfig.log.error(authentication_1.authErrors.badAuthProviderInfo);
    }
}
exports.selectNewApplicationName = selectNewApplicationName;
;
/**
 * create SIMBA app
 * @param config
 * @returns
**/
async function createApplicationForOrg(config) {
    const authStore = await config.authStore();
    const url = `v2/organisations/${config.organisation.id}/applications/`;
    const appName = await selectNewApplicationName(config);
    const postData = {
        name: appName,
        display_name: appName,
    };
    if (authStore) {
        try {
            return await authStore.doPostRequest(url, postData, 'application/json');
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error.response.data)}`)}`);
            }
            else {
                lib_1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error)}`)}`);
            }
            if (axios_1.default.isAxiosError(error) && error.message === "Request failed with status code 500") {
                lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright('\nsimba: Auth token expired, please log in again')}`);
                authStore.logout();
                await authStore.loginAndGetAuthToken();
                return await createApplicationForOrg(config);
            }
        }
    }
    else {
        lib_1.SimbaConfig.log.error(authentication_1.authErrors.badAuthProviderInfo);
    }
}
;
/**
 * choose SIMBA app from list
 * @param config
 * @param url
 * @returns
 */
async function chooseApplicationFromList(config, url) {
    const entryParams = {
        config,
        url,
    };
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(entryParams)}`);
    if (!url) {
        url = `v2/organisations/${config.organisation.id}/applications/`;
    }
    const appResponse = await exports.getList(config, url);
    lib_1.SimbaConfig.log.debug(`appResponse: ${JSON.stringify(appResponse)}`);
    if (!appResponse) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : no applications in list. You probably need to login again.')}`);
        return;
    }
    if (appResponse.results) {
        lib_1.SimbaConfig.log.debug(`appResponse.results: ${JSON.stringify(appResponse.results)}`);
    }
    if (!appResponse.results || !appResponse.results.length) {
        lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: Your organisation does not have any apps. Please create one:`)}`);
        return await createApplicationForOrg(config);
    }
    const apps = {
        next: appResponse.next,
        prev: appResponse.prev,
        data: appResponse.results.reduce((map, obj) => {
            const data = Object.assign(Object.assign({}, obj), { id: obj.id });
            map[data.display_name] = data;
            return map;
        }, {}),
    };
    const choices = [];
    if (apps.prev) {
        choices.push({
            title: '<-',
            description: 'Previous choices',
            value: 'prev'
        });
    }
    if (apps.next) {
        choices.push({ title: '-> Next Page', description: 'Next choices', value: 'next' });
    }
    for (const [key, val] of Object.entries(apps.data)) {
        choices.push({ title: key, value: val });
    }
    if (apps.next) {
        choices.push({ title: '-> Next Page', description: 'Next choices', value: 'next' });
    }
    const response = await prompts_1.default({
        type: 'select',
        name: 'application',
        message: 'Please pick an application',
        choices,
    });
    lib_1.SimbaConfig.log.debug(`selected application: ${JSON.stringify(response.application)}`);
    if (response.application === 'prev') {
        return chooseApplicationFromList(config, apps.prev);
    }
    else if (response.application === 'next') {
        return chooseApplicationFromList(config, apps.next);
    }
    if (!response.application) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright('\nsimba: EXIT : No Application Selected!')}`);
        throw new Error('No Application Selected!');
    }
    config.application = response.application;
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(response.application)}`);
    return response.application;
}
exports.chooseApplicationFromList = chooseApplicationFromList;
;
/**
 * fetch available blockchains
 * @param config
 * @param url
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function getBlockchains(config, url) {
    const entryParams = {
        config,
        url,
    };
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(entryParams)}`);
    if (!url) {
        url = `v2/organisations/${config.organisation.id}/blockchains/`;
    }
    const chains = await exports.getList(config, url);
    const choices = [];
    chains.results.forEach((chain) => {
        choices.push({
            title: chain.display_name,
            value: chain.name,
        });
    });
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(choices)}`);
    return choices;
}
exports.getBlockchains = getBlockchains;
;
/**
 * fetch available storages
 * @param config
 * @param url
 * @returns
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
async function getStorages(config, url) {
    const entryParams = {
        config,
        url,
    };
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(entryParams)}`);
    if (!url) {
        url = `v2/organisations/${config.organisation.id}/storage/`;
    }
    const storages = await exports.getList(config, url);
    const choices = [];
    storages.results.forEach((storage) => {
        choices.push({
            title: storage.display_name,
            value: storage.name,
        });
    });
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(choices)}`);
    return choices;
}
exports.getStorages = getStorages;
;
/**
 * gets field from primary contract (in simba.json) ABI
 * @param name
 * @returns
 */
async function getFieldFromPrimaryContractABI(name) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${name}`);
    const abi = await getABIForPrimaryContract();
    for (let i = 0; i < abi.length; i++) {
        const entry = abi[i];
        if (entry.name === name) {
            lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(entry)}`);
            return entry;
        }
    }
    lib_1.SimbaConfig.log.debug(`:: EXIT : {}`);
    return {};
}
exports.getFieldFromPrimaryContractABI = getFieldFromPrimaryContractABI;
/**
 * get constructor for primary contract
 * @returns
 */
async function primaryContractConstructor() {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const abi = await getABIForPrimaryContract();
    lib_1.SimbaConfig.log.debug(`:: abi for primary contract: ${JSON.stringify(abi)}`);
    for (let i = 0; i < abi.length; i++) {
        const entry = abi[i];
        if (entry.type === "constructor") {
            lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(entry)}`);
            return entry;
        }
    }
    lib_1.SimbaConfig.log.debug(`:: EXIT : {}`);
    return {};
}
exports.primaryContractConstructor = primaryContractConstructor;
/**
 * aids in specifying types when asking user to input values
 * @returns
 */
async function primaryConstructorInputs() {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const constructor = await primaryContractConstructor();
    const constructorInputs = constructor.inputs ? constructor.inputs : [];
    const inputs = [];
    for (let i = 0; i < constructorInputs.length; i++) {
        const input = constructorInputs[i];
        const type = input.type;
        const name = input.name;
        inputs.push({
            type,
            name,
        });
    }
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${JSON.stringify(inputs)}`);
    return inputs;
}
exports.primaryConstructorInputs = primaryConstructorInputs;
/**
 * tells us whether a contract's constructor has params
 * We use this function so we know whether to prompt the
 * user to specify the method they want to use to provide param values
 * @returns
 */
async function primaryConstructorRequiresArgs() {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const constructor = await primaryContractConstructor();
    const inputs = constructor.inputs;
    let requiresArgs = false;
    if (inputs && inputs.length > 0) {
        requiresArgs = true;
    }
    lib_1.SimbaConfig.log.debug(`:: EXIT : ${requiresArgs}`);
    return requiresArgs;
}
exports.primaryConstructorRequiresArgs = primaryConstructorRequiresArgs;
//# sourceMappingURL=api.js.map