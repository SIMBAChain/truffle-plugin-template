import Configstore from "configstore";
export declare const AUTHKEY = "SIMBAAUTH";
interface PollingConfig {
    maxAttempts: number;
    interval: number;
}
export declare enum AuthProviders {
    KEYCLOAK = "keycloak",
    KEYCLOAKOAUTH2 = "KeycloakOAuth2"
}
interface AuthErrors {
    headersError: string;
    keycloakCertsError: string;
    verificationInfoError: string;
    authTokenError: string;
    noClientIDError: string;
    noBaseURLError: string;
    noAuthURLError: string;
    noRealmError: string;
    badAuthProviderInfo: string;
}
export declare const authErrors: AuthErrors;
interface KeycloakAccessToken {
    access_token: string;
    expires_in: number;
    expires_at?: number;
    refresh_expires_in: number;
    refresh_expires_at: number;
    refresh_token: string;
    token_type: string;
    not_before_policy: number;
    session_state: string;
    scope: string;
}
interface ClientCredsToken {
    access_token: string;
    expires_in: number;
    token_type: string;
    scope: string;
    retrieved_at?: string;
    expires_at: number;
}
/**
 * This class handles our login for keycloak device login
 */
export declare class KeycloakHandler {
    private config;
    private projectConfig;
    baseURL: string;
    private verificationInfo;
    private configBase;
    private authErrors;
    private _loggedIn;
    constructor(config?: Configstore, projectConfig?: Configstore, tokenExpirationPad?: number);
    /**
     * handles login
     */
    performLogin(interactive?: boolean): Promise<any>;
    /**
     * used as field for our auth token
     * @returns
     */
    protected getConfigBase(): string;
    /**
     * self explanatory
     * this method does not necessarily serve a big purpose right now,
     * may want to remove in future
     * @param status
     */
    setLoggedInStatus(status: boolean): void;
    /**
     * used to avoid trying to login in when the process has already begun
     * @returns
     */
    isLoggedIn(): boolean;
    /**
     * deletes our auth info / auth token in authconfig.json
     */
    logout(): Promise<void>;
    /**
     * deletes auth info in authconfig.json
     */
    protected deleteAuthInfo(): void;
    /**
     * tells us whether a certain key exists in our configstore (authconfig.json)
     * @param key
     * @returns
     */
    protected hasConfig(key: string): boolean;
    /**
     * return value for key from configstore (authconfig.json)
     * @param key
     * @returns
     */
    getConfig(key: string): any;
    /**
     * pertains to configstore (authconfig.json)
     * @param key
     * @param value
     * @returns
     */
    protected getOrSetConfig(key: string, value: any): any;
    /**
     * sets key/value in configstore (authconfig.json)
     * @param key
     * @param value
     * @returns
     */
    setConfig(key: string, value: any): any;
    /**
     * deletes keyu, value in configstore (authconfig.json)
     * @param key
     * @returns
     */
    protected deleteConfig(key: string): void;
    /**
     * uses expires_in from authtoken to create more human readable version,
     * as well as expires_at
     * @param auth
     * @returns
     */
    parseExpiry(auth: any): any;
    /**
     * retrieves auth token using client creds, sets authtoken in authconfig.json
     * @returns
     */
    getAndSetAuthTokenFromClientCreds(): Promise<any>;
    /**
     * first step in logging in. returns verification info, including a URI,
     * to allow user to login.
     * @returns
     */
    private getVerificationInfo;
    /**
     * reads out URI user should navigate to for login
     * @returns
     */
    loginUser(): Promise<void | string>;
    /**
     * allows user to login after they have navigated to the URI from loginUser()
     * @param pollingConfig
     * @param refreshing
     * @returns
     */
    getAuthToken(pollingConfig?: PollingConfig, refreshing?: boolean): Promise<KeycloakAccessToken | void>;
    /**
     * checks if auth token is expired. used as a check before we make http call
     * idea is to check for bad token before http call, if possible
     * @returns
     */
    tokenExpired(): boolean;
    /**
     * checks if refresh token is expired. used as a check before we make http call
     * idea is to check for bad token before http call, if possible
     * @returns
     */
    refreshTokenExpired(): boolean;
    /**
     * refresh auth token using refresh token
     * @returns {Promise<KeycloakAccessToken | ClientCredsToken | void>}
     */
    refreshToken(): Promise<KeycloakAccessToken | ClientCredsToken | void>;
    /**
     * used for both client creds and device login
     * @param refreshing specifies whether just refreshing
     * @param interactive device login if true, client creds if false
     * @returns
     */
    loginAndGetAuthToken(refreshing?: boolean, interactive?: boolean): Promise<KeycloakAccessToken | ClientCredsToken | void>;
    /**
     * returns headers with access token
     * @returns {Promise<Record<any, any> | void>}
     */
    accessTokenHeader(): Promise<Record<any, any> | void>;
    /**
     * creates full url given our baseURL and an endpoint, while handling redundant "/"
     * @param urlExtension
     * @returns {string}
     */
    buildURL(endpoint: string): string;
    /**
     * make get request. currently uses Axios
     * @param url
     * @param contentType
     * @param _queryParams
     * @param _buildURL - builds url using baseURL and url if true
     * @returns {Promise<Record<any, any> | Error | void>}
     */
    doGetRequest(url: string, contentType?: string, _queryParams?: Record<any, any>, _buildURL?: boolean): Promise<Record<any, any> | Error | void>;
    /**
     * do post request. uses axios library
     * @param url
     * @param _postData
     * @param contentType
     * @param _buildURL - builds url using baseURL and url if true
     * @returns {Promise<Record<any, any> | void>}
     */
    doPostRequest(url: string, _postData?: Record<any, any>, contentType?: string, _buildURL?: boolean): Promise<Record<any, any> | void>;
    /**
     * do put request
     * @param url
     * @param _postData
     * @param contentType
     * @param _buildURL - builds url using baseURL and url if true
     * @returns {Promise<Record<any, any> | void>}
     */
    doPutRequest(url: string, _postData?: Record<any, any>, contentType?: string, _buildURL?: boolean): Promise<Record<any, any> | void>;
    /**
     * do put or post request. uses axios library
     * @param method
     * @param url
     * @param _postData
     * @param contentType
     * @param _buildURL - builds url using baseURL and url if true
     * @returns {Promise<Record<any, any> | void>}
     */
    doPutPostRequest(method: string, url: string, _postData?: Record<any, any>, contentType?: string, _buildURL?: boolean): Promise<Record<any, any> | void>;
    /**
     *
     * @param url
     * @param contentType
     * @param _buildURL - builds url using baseURL and url if true
     * @returns {Promise<Record<any, any> | void>}
     */
    doDeleteRequest(url: string, contentType?: string, _buildURL?: boolean): Promise<Record<any, any> | void>;
}
export {};
//# sourceMappingURL=authentication.d.ts.map