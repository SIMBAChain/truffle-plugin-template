"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.contractSimbaPath = exports.contractAbsolutePath = exports.absolutePaths = exports.promisifiedReadFile = exports.walkDirForContracts = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const process_1 = require("process");
const _1 = require("./");
const chalk_1 = __importDefault(require("chalk"));
const SimbaPath = "SimbaImports";
/**
 * function used in many operations in this module. helps us find compiled contracts
 * @param dir
 * @param extension
 * @returns {Promise<string[]>}
 */
exports.walkDirForContracts = (dir, extension) => new Promise((resolve, reject) => {
    fs.readdir(dir, { withFileTypes: true }, async (err, entries) => {
        if (err) {
            return reject(err);
        }
        let files = [];
        for (const entry of entries) {
            if (entry.isFile()) {
                const filePath = path.join(dir, entry.name);
                if (!extension || (extension && path.parse(filePath).ext === extension)) {
                    files.push(filePath);
                }
            }
            else if (entry.isDirectory()) {
                try {
                    const subFiles = await exports.walkDirForContracts(path.join(dir, entry.name), extension);
                    files = files.concat(subFiles);
                }
                catch (e) {
                    reject(e);
                }
            }
        }
        resolve(files);
    });
});
/**
 * helps read file once we've found it
 * @param filePath
 * @param options
 * @returns
 */
exports.promisifiedReadFile = (filePath, options) => new Promise((resolve, reject) => {
    fs.readFile(filePath, options, (err, data) => {
        if (err) {
            return reject(err);
        }
        return resolve(data);
    });
});
/**
 * returns a promise containing an object with {contractName: pathToContractLocation}
 * @returns [Promise<Record<any, any> | void>]
 */
async function absolutePaths() {
    _1.SimbaConfig.log.debug(`:: ENTER :`);
    const buildDir = _1.SimbaConfig.buildDirectory;
    let files = [];
    const absolutePathMap = {};
    try {
        files = await exports.walkDirForContracts(buildDir, '.json');
    }
    catch (e) {
        const err = e;
        if (err.code === 'ENOENT') {
            // not logging as an error because it's not an error in every instance
            // the user may not have compiled yet, and that's OK
            _1.SimbaConfig.log.debug(`${chalk_1.default.redBright(`\nsimba: Simba was not able to find any build artifacts.\nDid you forget to compile?\n`)}`);
        }
        return absolutePathMap;
    }
    for (const file of files) {
        if (file.endsWith('Migrations.json') || file.endsWith('dbg.json')) {
            continue;
        }
        const buf = await exports.promisifiedReadFile(file, { flag: 'r' });
        if (!(buf instanceof Buffer)) {
            continue;
        }
        const parsed = JSON.parse(buf.toString());
        const contractName = parsed.contractName;
        const contractSourceName = parsed.sourceName;
        const astAndOtherInfo = await _1.getASTAndOtherInfo(contractName, contractSourceName);
        let absPath = astAndOtherInfo.ast.absolutePath ?
            astAndOtherInfo.ast.absolutePath :
            path.join("contracts", `${contractName}.sol`);
        // the following line is for truffle, since it prepends paths with "project:/"
        if (absPath.startsWith("project:/")) {
            absPath = absPath.split("project:/")[1];
        }
        absolutePathMap[contractName] = absPath;
    }
    _1.SimbaConfig.log.debug(`:: EXIT : absolutePathMap : ${JSON.stringify(absolutePathMap)}`);
    return absolutePathMap;
}
exports.absolutePaths = absolutePaths;
/**
 * gives the absolute path for a single contract in project
 * @param _absolutePaths
 * @param contractName
 * @returns {string}
 */
function contractAbsolutePath(_absolutePaths, contractName) {
    const entryParams = {
        _absolutePaths,
        contractName,
    };
    _1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(entryParams)}`);
    const contractPath = _absolutePaths[contractName] ?
        _absolutePaths[contractName] :
        path.join("contracts", `${contractName}.sol`);
    _1.SimbaConfig.log.debug(`:: EXIT : ${contractPath}`);
    return contractPath;
}
exports.contractAbsolutePath = contractAbsolutePath;
/**
 * gives us the path to a contract, but within contracts/simbaimports/
 * @param _absolutePaths
 * @param contractName
 * @returns {string}
 */
function contractSimbaPath(_absolutePaths, contractName) {
    _1.SimbaConfig.log.debug(`:: ENTER : }`);
    const contractPath = contractAbsolutePath(_absolutePaths, contractName);
    let base;
    if (contractPath.includes("/")) {
        base = contractPath.split("/")[0];
    }
    else {
        base = contractPath.split("\\")[0];
    }
    let newPathWithSimba = path.join(base, SimbaPath, contractPath.slice(base.length));
    const newAbsoluteSimbaPath = path.join(process_1.cwd(), newPathWithSimba);
    const newAbsoluteDir = path.dirname(newAbsoluteSimbaPath);
    if (!fs.existsSync(newAbsoluteDir)) {
        fs.mkdirSync(newAbsoluteDir, { recursive: true });
    }
    // we're writing to contractName.sol instead of original file name,
    // because if there were multiple contracts in someFileName.sol, we would lose
    // all but one of them
    const fileNameReplacedWithContractName = path.join(newAbsoluteDir, `${contractName}.sol`);
    _1.SimbaConfig.log.debug(`:: EXIT : ${fileNameReplacedWithContractName}`);
    return fileNameReplacedWithContractName;
}
exports.contractSimbaPath = contractSimbaPath;
//# sourceMappingURL=contractfinder.js.map