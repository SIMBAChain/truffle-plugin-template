import { LogLevel } from "./logger";
import { Logger } from "tslog";
import Configstore from 'configstore';
import { KeycloakHandler } from './authentication';
export declare enum AllDirs {
    BUILDDIRECTORY = "buildDirectory",
    ARTIFACTDIRECTORY = "artifactDirectory",
    CONTRACTDIRECTORY = "contractDirectory"
}
export declare enum EnvVariableKeys {
    ID = "ID",
    SECRET = "SECRET",
    AUTHENDPOINT = "ENDPOINT",
    BASE_URL = "BASE_URL"
}
declare enum SimbaEnvFiles {
    DOT_SIMBACHAIN_DOT_ENV = ".simbachain.env",
    SIMBACHAIN_DOT_ENV = "simbachain.env",
    DOT_ENV = ".env"
}
export declare const simbaEnvFilesArray: SimbaEnvFiles[];
/**
 * this class handles our configstore operations (eg reading simba.json)
 * http operations are handled by our authStore property.
 *
 * the two main files SimbaConfig manipulates and reads from are simba.json and authconfig.json
 *
 * If you notice throughout this class, many methods are defined in static
 * and instance methods. This was so that some older code that was integrated,
 * that uses instance methods, would still be supported.
 */
export declare class SimbaConfig {
    static _web3Suite: string;
    static _configStore: Configstore;
    static _projectConfigStore: Configstore;
    static help: boolean;
    static _authStore: KeycloakHandler;
    static _application: any;
    static _organisation: any;
    static _build_directory: string;
    static _log: Logger;
    static envVars: Record<any, any>;
    /**
     *  many of these instance properties are not actually uses
     *  they're just defined here for debugging/logging purposes
     */
    constructor();
    /**
     * handles our auth / access token info - currently authconfig.json
     */
    static get ConfigStore(): Configstore;
    get ConfigStore(): Configstore;
    /**
     * handles project info, contained in simba.json
     */
    static get ProjectConfigStore(): Configstore;
    get ProjectConfigStore(): Configstore;
    /**
     * looks for baseURL in simba.json
     * @returns {string | void}
     */
    private static retrieveBaseAPIURLFromConfigStore;
    /**
     * looks for SIMBA_API_BASE_URL in env vars
     * first looks in local project (.simbachain.env, simbachain.env, .env)
     * then looks in SIMBA_HOME location, iterating through those same file names
     * @returns {string | void}
     */
    private static retrieveBaseAPIURLFromEnvVars;
    /**
     * checks simba.json first, then looks for env vars
     * @returns {string}
     */
    static retrieveBaseAPIURL(): string;
    /**
     * this method only gets called once, when a process first tries to retrieve an env var
     * if SimbaConfig.envVars's values is zero length, then we call this method
     *
     * The code is a bit convoluted, so here's the process:
     * 1. iterate through file names of (.simbachain.env, simbachain.env, .env) in our project root
     * 2. we then loop through each of our simba keys:"ID", "SECRET", "ENDPOINT", and "BASE_URL"
     * 3. for each one of those keys, we search for `SIMBA_AUTH_CLIENT_${key}`
     * 4. once we have found a value for "ID", "SECRET", "ENDPOINT", and "BASE_URL", based on the above keys that users can actually set (in 3), we return them and set them as SimbaConfig.envVars
     * 5. we then run through 1-4 again, but we use SIMBA_HOME instead of project root
     * @returns {Promise<Record<any, any>>}
     */
    static setEnvVars(): Record<any, any>;
    /**
     * retrieves value for env var key. looks for:
     * `SIMBA_AUTH_CLIENT_${envVarKey}`
     *
     * if SimbaConfig.envVars values has zero length, we first call SimbaConfig.setEnvVars
     * @param envVarKey
     * @returns
     */
    static retrieveEnvVar(envVarKey: EnvVariableKeys): string | void;
    retrieveEnvVar(envVarKey: EnvVariableKeys): Promise<string | void>;
    /**
     * this method is used in the plugins to reset simba.json, but with more control over what exactly gets reset
     * @param previousSimbaJson
     * @param newOrg
     * @param forceReset - basically wipes all of simba.json if true, dependent on value of keepOrgAndApp
     * @param keepOrgAndApp
     * @returns
     */
    static resetSimbaJson(previousSimbaJson: Record<any, any>, newOrg?: string | Record<any, any> | unknown, forceReset?: boolean, keepOrgAndApp?: boolean): void;
    /**
     * used to delete field in simba.json
     * @param key
     */
    static deleteSimbaJsonField(key: string): void;
    deleteSimbaJsonField(key: string): void;
    /**
     * deletes authProviderInfo in simba.json
     */
    static deleteAuthProviderInfo(): void;
    deleteAuthProviderInfo(): void;
    /**
     * retrieves and sets authProviderInfo in simba.json, based on our baseAPI (or SIMBA)AUTH_CLIENT_ID or other iteration of key)
     * @returns {Promise<any>}
     */
    static setAndGetAuthProviderInfo(): Promise<any>;
    /**
     * currently only returns KeycloakHandler, since we no longer use AzureHandler
     * @returns {Promise<KeycloakHandler | null>}
     */
    static authStore(): Promise<KeycloakHandler | null>;
    authStore(): Promise<KeycloakHandler | null>;
    /**
     * if user has modified build, contract, artifact directory for their project,
     * then it grabs these and returns them from simba.json
     * @returns {Record<any, any>}
     */
    static allDirs(): Record<any, any>;
    allDirs(): Record<any, any>;
    /**
     * prints chalked directories
     */
    static printChalkedDirs(): void;
    printChalkedDirs(): void;
    /**
     * to determine where compiled contracts are stored, based on web3Suite (hardhat, truffle, etc.)
     * @returns {string}
     */
    static get artifactDirectory(): string;
    get artifactDirectory(): string;
    /**
     * allows user to override default directories for build, contract, artifact, etc.
     * @param dirName
     * @param dirPath
     * @returns {void}
     */
    static setDirectory(dirName: AllDirs, dirPath: string): void;
    setDirectory(dirName: AllDirs, dirPath: string): void;
    /**
     * setter for artifactDirectory in simba.json
     */
    static set artifactDirectory(dirPath: string);
    set artifactDirectory(dirPath: string);
    /**
     * used for Hardhat, since some build info is stored in separate file from main artifact info
     */
    static get buildInfoDirectory(): string;
    get buildInfoDirectory(): string;
    /**
     * getter for buildDirectory
     * @returns {string}
     */
    static get buildDirectory(): string;
    get buildDirectory(): string;
    /**
     * setter for buildDirectory in simba.json
     */
    static set buildDirectory(dirPath: string);
    set buildDirectory(dirPath: string);
    /**
     * getter for contractDirectory
     * Not used in standard flow, since users shouldn't typically modify this value
     */
    static get contractDirectory(): string;
    get contractDirectory(): string;
    /**
     * setter for contractDirectory in simba.json
     */
    static set contractDirectory(dirPath: string);
    set contractDirectory(dirPath: string);
    /**
     * this is what we use for logging throughout our plugins
     * @returns {Logger}
     */
    static get log(): Logger;
    get log(): Logger;
    /**
     * how we get loglevel throughout our plugins
     * @returns {LogLevel}
     */
    static get logLevel(): LogLevel;
    get logLevel(): LogLevel;
    /**
     * how we set loglevel throughout our plugins
     */
    static set logLevel(level: LogLevel);
    set logLevel(level: LogLevel);
    /**
     * getter for organisation from our simba.json
     */
    static get organisation(): any;
    get organisation(): any;
    /**
     * setter for organisation in simba.json
     */
    static set organisation(org: any);
    set organisation(org: any);
    /**
     * getter for application in simba.json
     * @returns {any}
     */
    static get application(): any;
    get application(): any;
    /**
     * setter for application in simba.json
     */
    static set application(app: any);
    set application(app: any);
}
export {};
//# sourceMappingURL=config.d.ts.map