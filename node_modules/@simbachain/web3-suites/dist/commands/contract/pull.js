"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pullAllMostRecentSolFilesAndSourceCode = exports.pullMostRecentFromContractName = exports.pullMostRecentSourceCodeFromContractName = exports.pullMostRecentRecentSolFileFromContractName = exports.pullAllMostRecentSourceCodeForSimbaJson = exports.pullSourceCodeForSimbaJson = exports.pullAllMostRecentContracts = exports.pullContractsInteractive = exports.pullContractFromContractDesign = exports.pullContractFromDesignId = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const lib_1 = require("../lib");
const prompts_1 = __importDefault(require("prompts"));
const axios_1 = __importDefault(require("axios"));
const list_1 = require("./list");
const authentication_1 = require("../lib/authentication");
/**
 * pull contract design from blocks to local project, based on designID
 * @param designID
 * @param useSimbaPath - if true, then we write to contracts/simbaimports
 * @param absPaths - absolute paths for contracts
 */
async function pullContractFromDesignId(designID, useSimbaPath = true, absPaths) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${designID}`);
    let contractDesign;
    const authStore = await lib_1.SimbaConfig.authStore();
    if (authStore) {
        const url = `v2/organisations/${lib_1.SimbaConfig.organisation.id}/contract_designs/${designID}`;
        const resp = await authStore.doGetRequest(url);
        lib_1.SimbaConfig.log.debug(`resp: ${JSON.stringify(resp)}`);
        if (resp) {
            contractDesign = resp;
            let contractFileName;
            if (useSimbaPath) {
                if (!absPaths) {
                    absPaths = await lib_1.absolutePaths();
                }
                contractFileName = lib_1.contractSimbaPath(absPaths, contractDesign.name);
            }
            else {
                contractFileName = path_1.default.join(lib_1.SimbaConfig.contractDirectory, `${contractDesign.name}.sol`);
            }
            lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: pulling file ${chalk_1.default.greenBright(`${contractDesign.name}`)} ---> ${chalk_1.default.greenBright(`${contractFileName}`)}`)}`);
            fs_1.default.writeFileSync(contractFileName, Buffer.from(contractDesign.code, 'base64').toString());
            lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`simba: finished pulling ${chalk_1.default.greenBright(`${contractDesign.name}`)} ---> ${chalk_1.default.greenBright(`${contractFileName}`)}`)}`);
        }
        else {
            lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: error acquiring contract design for ${chalk_1.default.greenBright(`${designID}`)}`)}`);
        }
        lib_1.SimbaConfig.log.debug(`:: EXIT :`);
    }
    else {
        lib_1.SimbaConfig.log.error(authentication_1.authErrors.badAuthProviderInfo);
    }
}
exports.pullContractFromDesignId = pullContractFromDesignId;
/**
 * pull contract design (.sol file) from blocks to local project's contracts
 * @param contractDesign
 * @param useSimbaPath
 * @param absPaths
 */
async function pullContractFromContractDesign(contractDesign, useSimbaPath = true, absPaths) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : ${JSON.stringify(contractDesign)}`);
    let contractFileName;
    if (useSimbaPath) {
        if (!absPaths) {
            absPaths = await lib_1.absolutePaths();
        }
        contractFileName = lib_1.contractSimbaPath(absPaths, contractDesign.name);
    }
    else {
        contractFileName = path_1.default.join(lib_1.SimbaConfig.contractDirectory, `${contractDesign.name}.sol`);
    }
    lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: pulling file ${chalk_1.default.greenBright(`${contractDesign.name}`)} ---> ${chalk_1.default.greenBright(`${contractFileName}`)}`)}`);
    fs_1.default.writeFileSync(contractFileName, Buffer.from(contractDesign.code, 'base64').toString());
    lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: finished pulling ${chalk_1.default.greenBright(`${contractDesign.name}`)} ---> ${chalk_1.default.greenBright(`${contractFileName}`)}`)}`);
    lib_1.SimbaConfig.log.debug(`:: EXIT :`);
}
exports.pullContractFromContractDesign = pullContractFromContractDesign;
/**
 * pull contract designs (.sol files) interactively from prompts, from blocks to local project's contracts
 * @param contractDesignArray
 * @param useSimbaPath
 * @param absPaths
 * @returns
 */
async function pullContractsInteractive(contractDesignArray, useSimbaPath = true, absPaths) {
    lib_1.SimbaConfig.log.debug(`:: ENTER : entryParams: ${JSON.stringify(contractDesignArray)}`);
    const NO = "NO";
    const YES = "YES";
    const overWriteOK = [NO, YES];
    const overWriteChoices = [];
    for (let i = 0; i < overWriteOK.length; i++) {
        const entry = overWriteOK[i];
        overWriteChoices.push({
            title: entry,
            value: entry,
        });
    }
    const overWriteChoice = await prompts_1.default({
        type: 'select',
        name: 'over_write_ok',
        message: '"simba pull" will overwrite local versions of .sol files in your contracts directory. Also, all pulled contracts will be written to the top level of your /contracts/ directory. Do you want to proceed?',
        choices: overWriteChoices,
    });
    if (!overWriteChoice.over_write_ok) {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: EXIT : no choice selected; exiting without pulling.`)}`);
        return;
    }
    if (overWriteChoice.over_write_ok === NO) {
        lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: EXIT : exiting without pulling.`)}`);
        return;
    }
    try {
        if (useSimbaPath) {
            if (!absPaths) {
                absPaths = await lib_1.absolutePaths();
            }
        }
        const contractDesigns = contractDesignArray ?
            contractDesignArray :
            await list_1.allContracts();
        const choices = [];
        if (contractDesigns) {
            for (let i = 0; i < contractDesigns.length; i++) {
                const title = `${chalk_1.default.green(contractDesigns[i].name)} :: ${chalk_1.default.green("id")} ${contractDesigns[i].id} :: ${chalk_1.default.green("created_on")} ${contractDesigns[i].created_on} :: ${chalk_1.default.green("updated_on")} ${contractDesigns[i].updated_on}`;
                const value = contractDesigns[i];
                choices.push({ title: title, value: value });
            }
        }
        else {
            lib_1.SimbaConfig.log.error(`\nsimba: error obtaining contracts`);
            return;
        }
        const chosen = await prompts_1.default({
            type: 'multiselect',
            name: 'contracts',
            message: `${chalk_1.default.cyanBright(`Please select all contracts you want to sync. Use the Space Bar to select or un-select a contract (You can also use -> to select a contract, and <- to un-select a contract). Hit Return/Enter when you are ready to sync your contracts. This will overwrite any local versions of selected contracts.`)}`,
            choices,
        });
        for (let i = 0; i < chosen.contracts.length; i++) {
            const contractDesign = chosen.contracts[i];
            await pullContractFromContractDesign(contractDesign, useSimbaPath, absPaths);
        }
        return;
    }
    catch (error) {
        if (axios_1.default.isAxiosError(error) && error.response) {
            lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error.response.data)}`)}`);
            return;
        }
        else {
            lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: EXIT : ${JSON.stringify(error)}`)}`);
            return;
        }
    }
}
exports.pullContractsInteractive = pullContractsInteractive;
/**
 * pull most recent design pattern (.sol file) from blocks to local project's contracts, for each design pattern in org
 * @param contractDesigns
 * @param useSimbaPath
 * @param absPaths
 */
async function pullAllMostRecentContracts(contractDesigns, useSimbaPath = true, absPaths) {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const contractNames = [];
    if (useSimbaPath) {
        if (!absPaths) {
            absPaths = await lib_1.absolutePaths();
        }
    }
    for (let i = 0; i < contractDesigns.length; i++) {
        if (contractNames.includes(contractDesigns[i].name)) {
            // this will avoid pulling old versions of contracts
            continue;
        }
        await pullContractFromContractDesign(contractDesigns[i], useSimbaPath, absPaths);
        contractNames.push(contractDesigns[i].name);
    }
    lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: all source code in simba.json up to date.`)}`);
    lib_1.SimbaConfig.log.debug(`:: EXIT :`);
}
exports.pullAllMostRecentContracts = pullAllMostRecentContracts;
/**
 * pull source code from blocks to simba.json
 * @param contractDesign
 */
function pullSourceCodeForSimbaJson(contractDesign) {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const contractsInfo = lib_1.SimbaConfig.ProjectConfigStore.get("contracts_info") ?
        lib_1.SimbaConfig.ProjectConfigStore.get("contracts_info") :
        {};
    const singleContractInfo = contractsInfo[contractDesign.name] ?
        contractsInfo[contractDesign.name] :
        {};
    singleContractInfo.design_id = contractDesign.id;
    singleContractInfo.source_code = Buffer.from(contractDesign.code, 'base64').toString();
    contractsInfo[contractDesign.name] = singleContractInfo;
    lib_1.SimbaConfig.ProjectConfigStore.set("contracts_info", contractsInfo);
    lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: pulling source code for ${chalk_1.default.greenBright(`${contractDesign.name}`)} ---> simba.json`)}`);
    lib_1.SimbaConfig.log.debug(`:: EXIT :`);
}
exports.pullSourceCodeForSimbaJson = pullSourceCodeForSimbaJson;
/**
 * writes most recent source code to simba.json for each contract design in org
 * this is important because the way we decide which contracts to export during
 * contract export is by comparing source code in simba.json to our compiled/build code
 * @param contractDesigns
 */
function pullAllMostRecentSourceCodeForSimbaJson(contractDesigns) {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: now pulling source code ---> simba.json`)}`);
    const contractNames = [];
    for (let i = 0; i < contractDesigns.length; i++) {
        if (contractNames.includes(contractDesigns[i].name)) {
            // this will avoid pulling old versions of contracts
            continue;
        }
        pullSourceCodeForSimbaJson(contractDesigns[i]);
        contractNames.push(contractDesigns[i].name);
    }
    lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: all source code in simba.json up to date.`)}`);
    lib_1.SimbaConfig.log.debug(`:: EXIT :`);
}
exports.pullAllMostRecentSourceCodeForSimbaJson = pullAllMostRecentSourceCodeForSimbaJson;
/**
 * pulls contract design (.sol file) from blocks to local project for single contract
 * @param contractName
 * @param contractDesignArray
 * @param useSimbaPath
 * @param absPaths
 * @returns
 */
async function pullMostRecentRecentSolFileFromContractName(contractName, contractDesignArray = null, useSimbaPath = true, absPaths) {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const contractDesigns = contractDesignArray ?
        contractDesignArray :
        await list_1.allContracts();
    if (useSimbaPath) {
        if (!absPaths) {
            absPaths = await lib_1.absolutePaths();
        }
    }
    if (contractDesigns) {
        for (let i = 0; i < contractDesigns.length; i++) {
            if (contractDesigns[i].name === contractName) {
                await pullContractFromContractDesign(contractDesigns[i], useSimbaPath, absPaths);
                lib_1.SimbaConfig.log.debug(`:: EXIT :`);
                return;
            }
        }
        lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: no contract found with name ${contractName}`)}`);
        lib_1.SimbaConfig.log.debug(`:: EXIT :`);
        return;
    }
    else {
        lib_1.SimbaConfig.log.error(`\nsimba: error obtaining contracts`);
    }
}
exports.pullMostRecentRecentSolFileFromContractName = pullMostRecentRecentSolFileFromContractName;
/**
 * updates source code in simba.json for individual contract
 * @param contractName
 * @param contractDesignArray
 * @returns
 */
async function pullMostRecentSourceCodeFromContractName(contractName, contractDesignArray) {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const contractDesigns = contractDesignArray ?
        contractDesignArray :
        await list_1.allContracts();
    if (contractDesigns) {
        for (let i = 0; i < contractDesigns.length; i++) {
            if (contractDesigns[i].name === contractName) {
                pullSourceCodeForSimbaJson(contractDesigns[i]);
                lib_1.SimbaConfig.log.debug(`:: EXIT :`);
                return;
            }
        }
        lib_1.SimbaConfig.log.info(`${chalk_1.default.cyanBright(`\nsimba: no contract found with name ${contractName}`)}`);
        lib_1.SimbaConfig.log.debug(`:: EXIT :`);
        return;
    }
    else {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: error obtaining contracts`)}`);
    }
}
exports.pullMostRecentSourceCodeFromContractName = pullMostRecentSourceCodeFromContractName;
/**
 * pulls source code to simba.json and .sol file to local contracts
 * @param contractName
 * @param contractDesignArray
 * @param useSimbaPath
 * @param absPaths
 * @returns
 */
async function pullMostRecentFromContractName(contractName, contractDesignArray, useSimbaPath = true, absPaths) {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const contractDesigns = contractDesignArray ?
        contractDesignArray :
        await list_1.allContracts();
    if (useSimbaPath) {
        if (!absPaths) {
            absPaths = await lib_1.absolutePaths();
        }
    }
    if (contractDesigns) {
        await pullMostRecentSourceCodeFromContractName(contractName, contractDesigns);
        await pullMostRecentRecentSolFileFromContractName(contractName, contractDesigns, useSimbaPath, absPaths);
        lib_1.SimbaConfig.log.debug(`:: EXIT :`);
        return;
    }
    else {
        lib_1.SimbaConfig.log.error(`${chalk_1.default.redBright(`\nsimba: error obtaining contracts`)}`);
        lib_1.SimbaConfig.log.debug(`:: EXIT :`);
        return;
    }
}
exports.pullMostRecentFromContractName = pullMostRecentFromContractName;
/**
 * pulls contract designs (.sol files) to local project's contracts,
 * and also pulls most recent source code to simba.json, from blocks
 * @param pullSourceCodeFiles
 * @param pullSolFiles
 * @param interactive
 * @param useSimbaPath
 * @param absPaths
 * @returns
 */
async function pullAllMostRecentSolFilesAndSourceCode(pullSourceCodeFiles = true, pullSolFiles = false, interactive = false, useSimbaPath = true, absPaths) {
    lib_1.SimbaConfig.log.debug(`:: ENTER :`);
    const contractDesigns = await list_1.allContracts();
    if (useSimbaPath) {
        if (!absPaths) {
            absPaths = await lib_1.absolutePaths();
        }
    }
    if (!contractDesigns) {
        lib_1.SimbaConfig.log.debug(`no contract designs found. exiting.`);
        return;
    }
    if (pullSourceCodeFiles) {
        pullAllMostRecentSourceCodeForSimbaJson(contractDesigns);
    }
    if (pullSolFiles) {
        if (interactive) {
            await pullContractsInteractive(contractDesigns, useSimbaPath, absPaths);
        }
        else {
            await pullAllMostRecentContracts(contractDesigns, useSimbaPath, absPaths);
        }
    }
}
exports.pullAllMostRecentSolFilesAndSourceCode = pullAllMostRecentSolFilesAndSourceCode;
//# sourceMappingURL=pull.js.map